{
  "name": "FP Notes",
  "tagline": "Experiments and Learnings in Functional Programming ",
  "body": "# FP Notes\r\nExperiments and Learnings in Functional Programming \r\n\r\n-  [Short cut fusion](https://rawgit.com/davidchase/fp-notes/master/short-cut-fusion.html) posted on  May 9, 2016\r\n-  [Zippers] (#zippers) Implementing functions w/ zip posted on June 20, 2016 \r\n\r\n\r\n***\r\n\r\n## Zippers\r\n\r\n### Backstory\r\nWhile working on a JavaScript application with a few colleagues using a great functional library called [Ramda](http://ramdajs.com/).\r\n\r\nWe came across a function that was in need of a bit of refactoring.\r\n\r\n**NB** The following code examples are written in concise es6 format.\r\n\r\n> Original\r\n\r\n```js\r\nconst {any, contains} = require('ramda');\r\nconst listURLs = ['http://google.com', 'http://ramdajs.com'];\r\nconst urlInList = url => any(val => contains(val, url))(listURLs);\r\n\r\nurlInList('http://google.com/images/bill+murray'); //true\r\n```\r\nThe code simply checks if `any` provided URL string is contained within the given list of URL strings.\r\n\r\nSo why refactor? Well, in the above definition we are focusing on the specific mechanics rather than composing functions together.\r\n\r\nHigh-level composition can promote a more compact and clear picture of what a function is going to do.\r\n\r\nBelow in the refactored version, we do just that:\r\n\r\n\r\n\r\n> Refactored\r\n\r\n```js\r\nconst {any, contains, identity, flip, useWith} = require('ramda');\r\nconst listURLs = ['http://google.com', 'http://ramdajs.com'];\r\nconst urlInList = useWith(any, [flip(contains), identity]);\r\n\r\nurlInList('http://google.com/images/bill+murray', listURLs); //true\r\n```\r\nCan you spot the discrepancy?\r\n\r\n- Other than new functions, there is no longer mention of `url` or `val` arguments in the function definition.\r\n- `listURLs` is no longer a [free variable](https://wiki.haskell.org/Free_variable) since we pass it in as an argument.  \r\n- `urlInList` is now a function that accepts two arguments: a string and a list of strings.\r\n\r\nThe key function to take note of is `useWith`. Below is the definition from the [source](http://ramdajs.com/docs/#useWith)\r\n> useWith: accepts a function fn and a list of transformer functions and returns a new curried function. When the new function is invoked, it calls the function fn with parameters consisting of the result of calling each supplied handler on successive arguments to the new function.\r\n\r\nA small visual... `any( flip(contains)(str), identity(listURLs) )` \r\n\r\n- [partially apply](https://wiki.haskell.org/Partial_application) a `str` to a flipped `contains` <sup>[^1]</sup> \r\n- pass the given `listURLs` to `identity`\r\n- finally use those results as arguments to `any`.\r\n\r\nIt's still a bit hazy so lets break it down. \r\n\r\nTo try to better understand the `useWith` function I decided to rebuild it using `zip` and you will see why in a moment.\r\n\r\n### Zip Definition\r\nA zip takes two lists and returns a new list where the values of each list are now **paired** up.\r\n\r\n```js\r\nconst pair = (fst, snd) => [fst, snd];\r\nconst map = (fn, xs) => xs.map(fn);\r\n// simple helpers\r\n\r\nconst zip = (xs, list) => map((x, idx) => pair(x, list[idx]), xs);\r\n//define a zip based on the above `map` & `pair` functions\r\n\r\nzip([1, 2, 3], ['a', 'b', 'c']); //=> [[1, 'a'], [2, 'b'], [3, 'c']]\r\n```\r\nSo far pretty straightforward, moving on:\r\n\r\n```js\r\nconst zipWith  = (fn, xs, arr) => map((x, i) => fn.apply(fn, pair(x, arr[i])), xs);\r\n\r\nzipWith(f, [1, 2, 3], ['a', 'b', 'c']) // [f(1, 'a'), f(2, 'b'), f(3, 'c')]\r\n\r\nzipWith((x, y) => [x, y], [1, 2, 3], ['a', 'b', 'c']) \r\n// = zip([1, 2, 3], ['a', 'b', 'c']) => [[1, 'a'], [2, 'b'], [3, 'c']]\r\n```\r\n\r\n### What do we have so far?\r\n\r\n- using `map` we build `zip` which takes two lists and pairs them up.\r\n- next we have `zipWith` that takes an additional argument: a function which gets called with both lists values.\r\n- finally we can also derive `zip` from `zipWith` shown above.\r\n\r\nLets keep going!\r\n\r\n```js\r\nconst inc = num => num + 1;\r\nconst addTen = num => num + 10;\r\nconst square = num => num * n;\r\nconst invoke = (fn, ...args) => fn(...args);\r\n\r\nzipWith(invoke, [inc, addTen, square], [2, 4, 6])\r\n// => [3, 14, 36]\r\n\r\n[invoke(inc, 2), invoke(addTen, 4), invoke(square, 6)] //=> [3, 14, 36]\r\n```\r\n\r\nHere we are simply zipping a list of functions with a list of values.\r\n\r\nThe pair of functions and values get passed as arguments to `invoke`.\r\n\r\nLets further expand on the above function:\r\n\r\n```js\r\nconst max = Math.max;\r\nconst zipThen = (after, xs, list) => after.apply(after, zipWith(invoke, xs, list));\r\n\r\nzipThen(max, [inc, addTen, square], [2, 4, 6]) //=> 36\r\n\r\nmax(...[invoke(inc, 2), invoke(addTen, 4), invoke(square, 6)]) //=> 36\r\n```\r\n\r\nWe took our `zipWith(invoke)` and added a function to be called afterwards.\r\n\r\nSo 1st we `zip` list of functions with list of values and `then` we call `max` on the resulting list.\r\n\r\n### Flashback Time\r\n\r\n```js\r\nuseWith(max, [inc, addTen, square])(2, 4, 6) //=> 36\r\n\r\nzipThen(max, [inc, addTen, square], [2, 4, 6]) //=> 36\r\n```\r\n\r\nThe [signatures](https://wiki.haskell.org/Type_signature) aren't identical but that shouldn't stop us!\r\n\r\nLets adjust the function definition:\r\n\r\n```js\r\nconst zipThen = (after, xs) => (...list) => after.apply(after, zipWith(invoke, xs, list));\r\n\r\nzipThen(max, [inc, addTen, square])(2, 4, 6) //=> 36\r\n\r\nuseWith(max, [inc, addTen, square])(2, 4, 6) //=> 36\r\n```\r\n\r\nI don't know about you guys but I kinda like `zipThen` feels a bit more descriptive. ;)\r\n\r\n\r\n\r\n### Footnotes\r\n[^1]: a fipped function simply means we have reversed its arguments from `contains(needle, haystack)` to `contains(haystack, needle)`",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}