{
  "name": "FP Notes",
  "tagline": "Experiments and Learnings in Functional Programming ",
  "body": "# FP Notes\r\nExperiments and Learnings in Functional Programming \r\n\r\n-  [Short cut fusion](#short-cut-fusion) posted on  May 9, 2016\r\n-  [Zippers] (#zippers) Implementing functions w/ zip posted on June 20, 2016 \r\n\r\n\r\n***\r\n\r\n## Zippers\r\n\r\n### Backstory\r\nWhile working on a JavaScript application with a few colleagues using a great functional library called [Ramda](http://ramdajs.com/).\r\n\r\nWe came across a function that was in need of a bit of refactoring.\r\n\r\n**NB** The following code examples are written in concise es6 format.\r\n\r\n> Original\r\n\r\n```js\r\nconst {any, contains} = require('ramda');\r\nconst listURLs = ['http://google.com', 'http://ramdajs.com'];\r\nconst urlInList = url => any(val => contains(val, url))(listURLs);\r\n\r\nurlInList('http://google.com/images/bill+murray'); //true\r\n```\r\nThe code simply checks if `any` provided URL string is contained within the given list of URL strings.\r\n\r\nSo why refactor? Well, in the above definition we are focusing on the specific mechanics rather than composing functions together.\r\n\r\nHigh-level composition can promote a more compact and clear picture of what a function is going to do.\r\n\r\nBelow in the refactored version, we do just that:\r\n\r\n\r\n\r\n> Refactored\r\n\r\n```js\r\nconst {any, contains, identity, flip, useWith} = require('ramda');\r\nconst listURLs = ['http://google.com', 'http://ramdajs.com'];\r\nconst urlInList = useWith(any, [flip(contains), identity]);\r\n\r\nurlInList('http://google.com/images/bill+murray', listURLs); //true\r\n```\r\nCan you spot the discrepancy?\r\n\r\n- Other than new functions, there is no longer mention of `url` or `val` arguments in the function definition.\r\n- `listURLs` is no longer a [free variable](https://wiki.haskell.org/Free_variable) since we pass it in as an argument.  \r\n- `urlInList` is now a function that accepts two arguments: a string and a list of strings.\r\n\r\nThe key function to take note of is `useWith`. Below is the definition from the [source](http://ramdajs.com/docs/#useWith)\r\n> useWith: accepts a function fn and a list of transformer functions and returns a new curried function. When the new function is invoked, it calls the function fn with parameters consisting of the result of calling each supplied handler on successive arguments to the new function.\r\n\r\nA small visual... `any( flip(contains)(str), identity(listURLs) )` \r\n\r\n- [partially apply](https://wiki.haskell.org/Partial_application) a `str` to a flipped `contains` <sup>[^1]</sup> \r\n- pass the given `listURLs` to `identity`\r\n- finally use those results as arguments to `any`.\r\n\r\nIt's still a bit hazy so lets break it down. \r\n\r\nTo try to better understand the `useWith` function I decided to rebuild it using `zip` and you will see why in a moment.\r\n\r\n### Zip Definition\r\nA zip takes two lists and returns a new list where the values of each list are now **paired** up.\r\n\r\n```js\r\nconst pair = (fst, snd) => [fst, snd];\r\nconst map = (fn, xs) => xs.map(fn);\r\n// simple helpers\r\n\r\nconst zip = (xs, list) => map((x, idx) => pair(x, list[idx]), xs);\r\n//define a zip based on the above `map` & `pair` functions\r\n\r\nzip([1, 2, 3], ['a', 'b', 'c']); //=> [[1, 'a'], [2, 'b'], [3, 'c']]\r\n```\r\nSo far pretty straightforward, moving on:\r\n\r\n```js\r\nconst zipWith  = (fn, xs, arr) => map((x, i) => fn.apply(fn, pair(x, arr[i])), xs);\r\n\r\nzipWith(f, [1, 2, 3], ['a', 'b', 'c']) // [f(1, 'a'), f(2, 'b'), f(3, 'c')]\r\n\r\nzipWith((x, y) => [x, y], [1, 2, 3], ['a', 'b', 'c']) \r\n// = zip([1, 2, 3], ['a', 'b', 'c']) => [[1, 'a'], [2, 'b'], [3, 'c']]\r\n```\r\n\r\n### What do we have so far?\r\n\r\n- using `map` we build `zip` which takes two lists and pairs them up.\r\n- next we have `zipWith` that takes an additional argument: a function which gets called with both lists values.\r\n- finally we can also derive `zip` from `zipWith` shown above.\r\n\r\nLets keep going!\r\n\r\n```js\r\nconst inc = num => num + 1;\r\nconst addTen = num => num + 10;\r\nconst square = num => num * n;\r\nconst invoke = (fn, ...args) => fn(...args);\r\n\r\nzipWith(invoke, [inc, addTen, square], [2, 4, 6])\r\n// => [3, 14, 36]\r\n\r\n[invoke(inc, 2), invoke(addTen, 4), invoke(square, 6)] //=> [3, 14, 36]\r\n```\r\n\r\nHere we are simply zipping a list of functions with a list of values.\r\n\r\nThe pair of functions and values get passed as arguments to `invoke`.\r\n\r\nLets further expand on the above function:\r\n\r\n```js\r\nconst max = Math.max;\r\nconst zipThen = (after, xs, list) => after.apply(after, zipWith(invoke, xs, list));\r\n\r\nzipThen(max, [inc, addTen, square], [2, 4, 6]) //=> 36\r\n\r\nmax(...[invoke(inc, 2), invoke(addTen, 4), invoke(square, 6)]) //=> 36\r\n```\r\n\r\nWe took our `zipWith(invoke)` and added a function to be called afterwards.\r\n\r\nSo 1st we `zip` list of functions with list of values and `then` we call `max` on the resulting list.\r\n\r\n### Flashback Time\r\n\r\n```js\r\nuseWith(max, [inc, addTen, square])(2, 4, 6) //=> 36\r\n\r\nzipThen(max, [inc, addTen, square], [2, 4, 6]) //=> 36\r\n```\r\n\r\nThe [signatures](https://wiki.haskell.org/Type_signature) aren't identical but that shouldn't stop us!\r\n\r\nLets adjust the function definition:\r\n\r\n```js\r\nconst zipThen = (after, xs) => (...list) => after.apply(after, zipWith(invoke, xs, list));\r\n\r\nzipThen(max, [inc, addTen, square])(2, 4, 6) //=> 36\r\n\r\nuseWith(max, [inc, addTen, square])(2, 4, 6) //=> 36\r\n```\r\n\r\nI don't know about you guys but I kinda like `zipThen` feels a bit more descriptive. ;)\r\n\r\n\r\n\r\n### Footnotes\r\n[^1]: a fipped function simply means we have reversed its arguments from `contains(needle, haystack)` to `contains(haystack, needle)`\r\n\r\n\r\n***\r\n\r\n## Short cut fusion\r\n> Optimization techinque that allows for removal of intermediate data structures. <sup>[1]</sup>\r\n\r\n##### Simple Example:\r\n```js\r\nconst list = [1,2,3,4];\r\n\r\n\r\n//|- [12, 18, 24, 30] <-- [4, 6, 8, 10] <-- [2, 3, 4, 5] <-- [1, 2, 3, 4]\r\nconst f = compose(map(triple), map(double), map(inc));\r\n\r\nf(list); // [12, 18, 24, 30]\r\n```\r\nThe above example is pretty straightforward we call `inc`, `double` and then `triple` on the \r\ngiven data `list`. For each of those function calls `map` creates a new list and passes it on\r\nto the next `map(f)`. Seems a bit wasteful :(\r\n\r\n```js\r\n//|- [12, 18, 24, 30] <------------------ [1, 2, 3, 4]\r\nconst ƒ = map(compose(triple, double, inc));\r\n\r\nƒ(list); // [12, 18, 24, 30]\r\n```\r\nSome what subtle but greatly beneficial improvement is to `compose` the functions provided to `map`\r\nand then call `map` on the result of that accumulation. The result is the same, however instead of mapping 3x\r\nover the same list it happens once. Therefore no unnecessary data structures created between the 1st function\r\ncall and the last.\r\n\r\n##### More Involved Example:\r\n\r\n```js\r\nconst list = range(1, 10);\r\n\r\nconst f = compose(map(inc), filter(odd), take(3)); // [3, 5, 7]\r\n```\r\nLooks very similar to 1st example, given a list we \r\n  \r\n  + `take` 3 values\r\n  + `filter` out the odd ones\r\n  + `map` to increment all of those values by 1\r\n \r\nThis again suffers from creating gratuitous lists in between the 1st and last function call.\r\n\r\nIdeally we would like to achieve a `composition` of those functions `take`, `filter` and `map` and\r\nonly \"loop\" through the data structure once.\r\n\r\nUnfortunately due to the different function signatures, in their current form you cannot `compose` them together. IOW because `map` takes a function, `filter` takes a predicate function and `take` expects a number you cannot build a single function to accomdate all of those cases...\r\n\r\nHowever if we re-define those functions in terms of something like `reduce` we may achieve the results\r\nwe want.\r\n\r\n```js\r\nconst mapƒ = (fn, xs) => reduce((acc, input) => concat(acc, fn(input)), [], xs);\r\nconst filterƒ = (pred, xs) => reduce((acc, input) => pred(input) ? concat(acc, pred(input)) : acc, [], xs);\r\nconst takeƒ = (n, xs) => reduce((acc, input) => acc.length !== n ? concat(acc, input) : acc, [], xs);\r\n```\r\nThis 1st pass shows that we are internally dependent on `reduce` and `concat` which we use to accumulate the values. This current situation does not allow us to be flexible in our usage of these new functions. IOW we cannot start with a list of values and return a single value ie: `[1,2,3,4] => 10`\t\r\n\r\n\r\n```js\r\nconst mapƒ = (fn, combineFn) => (acc, input) => combineFn(acc, fn(input));\r\nconst filterƒ = (pred, combineFn) => (acc, input) => pred(input) ? combineFn(acc, input) : acc;\r\nconst takeƒ = (n, combineFn) => (acc, input) => acc.length !== n ? combineFn(acc, input) : acc;\r\n\r\n```\r\nIn this 2nd attempt we have removed the dependency on a internal `reduce` function as well as a way to accumulate the values. It is now an argument called `combineFn`. So now we have 3 new functions that\r\nhave a way to accumulate values and a reducing function with the signature `(acc, input)` which is the same as the 1st argument to reduce.\r\n\r\n```js\r\nreduce(mapƒ(add(10), concat), [], range(1, 5)); // [11, 12, 13, 14]\r\n```\r\nAbove we have a typical usage of the newly created `mapβ` using `concat` as the `combineFn`\r\n\r\n```js\r\nreduce(mapƒ(inc, add), 0, range(1, 5)); // 14\r\n```\r\nIn this example we use `add` as the accumulator (combineFn).\r\n\r\n```js\r\nreduce(mapƒ(inc, filterƒ(odd, takeƒ(3, concat))), [], range(1, 10)); // [3, 5, 7]\r\n```\r\n\r\nFinally we can create a function \"composition\" with all of the new functions as well as a way to accumulate values. We get the same results as the example at the beginning of this section... but with a single \"loop\" and no intermediate data structures\r\n\r\n*Bonus:*\r\n\r\n```js\r\nconst mapƒ = curryN(2, (fn, combineFn) => (acc, input) => combineFn(acc, fn(input)));\r\nconst filterƒ = curryN(2, (pred, combineFn) => (acc, input) => pred(input) ? combineFn(acc, input) : acc);\r\nconst takeƒ = curryN(2, (n, combineFn) => (acc, input) => acc.length !== n ? combineFn(acc, input) : acc);\r\n\r\nconst ƒ = compose(mapƒ(inc), filterƒ(x => x % 2 !== 0), takeƒ(3));\r\n\r\nreduce(ƒ(concat), [], range(1, 10)) // [3, 5, 7]\r\n```\r\n\r\nAs a bonus using `curryN` and `compose` from a library like [ramda](http://ramdajs.com). We can create nice reusable compositions for our `reduce` function. **NB** typical composition is right-left but in our case the functions get applied left-right (map gets called 1st).\r\n\r\n#### References \r\n- [https://wiki.haskell.org/Short_cut_fusion](https://wiki.haskell.org/Short_cut_fusion)\r\n- [http://www.slideshare.net/drboolean/millionways](http://www.slideshare.net/drboolean/millionways)\r\n[1]: https://wiki.haskell.org/Short_cut_fusion",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}