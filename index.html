<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>FP Notes by davidchase</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">FP Notes</h1>
      <h2 class="project-tagline">Experiments and Learnings in Functional Programming </h2>
      <a href="https://github.com/davidchase/fp-notes" class="btn">View on GitHub</a>
      <a href="https://github.com/davidchase/fp-notes/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/davidchase/fp-notes/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <h1>
<a id="fp-notes" class="anchor" href="#fp-notes" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>FP Notes</h1>

<p>Experiments and Learnings in Functional Programming </p>

<ul>
<li> <a href="#short-cut-fusion">Short cut fusion</a> posted on  May 9, 2016</li>
<li> <a href="#zippers">Zippers</a> Implementing functions w/ zip posted on June 20, 2016 </li>
</ul>

<hr>

<h2>
<a id="zippers" class="anchor" href="#zippers" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Zippers</h2>

<h3>
<a id="backstory" class="anchor" href="#backstory" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Backstory</h3>

<p>While working on a JavaScript application with a few colleagues using a great functional library called <a href="http://ramdajs.com/">Ramda</a>.</p>

<p>We came across a function that was in need of a bit of refactoring.</p>

<p><strong>NB</strong> The following code examples are written in concise es6 format.</p>

<blockquote>
<p>Original</p>
</blockquote>

<div class="highlight highlight-source-js"><pre><span class="pl-k">const</span> {<span class="pl-c1">any</span>, <span class="pl-c1">contains</span>} <span class="pl-k">=</span> <span class="pl-c1">require</span>(<span class="pl-s"><span class="pl-pds">'</span>ramda<span class="pl-pds">'</span></span>);
<span class="pl-k">const</span> <span class="pl-c1">listURLs</span> <span class="pl-k">=</span> [<span class="pl-s"><span class="pl-pds">'</span>http://google.com<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>http://ramdajs.com<span class="pl-pds">'</span></span>];
<span class="pl-k">const</span> <span class="pl-c1">urlInList</span> <span class="pl-k">=</span> <span class="pl-smi">url</span> <span class="pl-k">=&gt;</span> <span class="pl-en">any</span>(<span class="pl-smi">val</span> <span class="pl-k">=&gt;</span> <span class="pl-en">contains</span>(val, url))(listURLs);

<span class="pl-en">urlInList</span>(<span class="pl-s"><span class="pl-pds">'</span>http://google.com/images/bill+murray<span class="pl-pds">'</span></span>); <span class="pl-c">//true</span></pre></div>

<p>The code simply checks if <code>any</code> provided URL string is contained within the given list of URL strings.</p>

<p>So why refactor? Well, in the above definition we are focusing on the specific mechanics rather than composing functions together.</p>

<p>High-level composition can promote a more compact and clear picture of what a function is going to do.</p>

<p>Below in the refactored version, we do just that:</p>

<blockquote>
<p>Refactored</p>
</blockquote>

<div class="highlight highlight-source-js"><pre><span class="pl-k">const</span> {<span class="pl-c1">any</span>, <span class="pl-c1">contains</span>, <span class="pl-c1">identity</span>, <span class="pl-c1">flip</span>, <span class="pl-c1">useWith</span>} <span class="pl-k">=</span> <span class="pl-c1">require</span>(<span class="pl-s"><span class="pl-pds">'</span>ramda<span class="pl-pds">'</span></span>);
<span class="pl-k">const</span> <span class="pl-c1">listURLs</span> <span class="pl-k">=</span> [<span class="pl-s"><span class="pl-pds">'</span>http://google.com<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>http://ramdajs.com<span class="pl-pds">'</span></span>];
<span class="pl-k">const</span> <span class="pl-c1">urlInList</span> <span class="pl-k">=</span> <span class="pl-en">useWith</span>(any, [<span class="pl-en">flip</span>(contains), identity]);

<span class="pl-en">urlInList</span>(<span class="pl-s"><span class="pl-pds">'</span>http://google.com/images/bill+murray<span class="pl-pds">'</span></span>, listURLs); <span class="pl-c">//true</span></pre></div>

<p>Can you spot the discrepancy?</p>

<ul>
<li>Other than new functions, there is no longer mention of <code>url</code> or <code>val</code> arguments in the function definition.</li>
<li>
<code>listURLs</code> is no longer a <a href="https://wiki.haskell.org/Free_variable">free variable</a> since we pass it in as an argument.<br>
</li>
<li>
<code>urlInList</code> is now a function that accepts two arguments: a string and a list of strings.</li>
</ul>

<p>The key function to take note of is <code>useWith</code>. Below is the definition from the <a href="http://ramdajs.com/docs/#useWith">source</a></p>

<blockquote>
<p>useWith: accepts a function fn and a list of transformer functions and returns a new curried function. When the new function is invoked, it calls the function fn with parameters consisting of the result of calling each supplied handler on successive arguments to the new function.</p>
</blockquote>

<p>A small visual... <code>any( flip(contains)(str), identity(listURLs) )</code> </p>

<ul>
<li>
<a href="https://wiki.haskell.org/Partial_application">partially apply</a> a <code>str</code> to a flipped <code>contains</code> <sup>[^1]</sup> </li>
<li>pass the given <code>listURLs</code> to <code>identity</code>
</li>
<li>finally use those results as arguments to <code>any</code>.</li>
</ul>

<p>It's still a bit hazy so lets break it down. </p>

<p>To try to better understand the <code>useWith</code> function I decided to rebuild it using <code>zip</code> and you will see why in a moment.</p>

<h3>
<a id="zip-definition" class="anchor" href="#zip-definition" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Zip Definition</h3>

<p>A zip takes two lists and returns a new list where the values of each list are now <strong>paired</strong> up.</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">const</span> <span class="pl-c1">pair</span> <span class="pl-k">=</span> (<span class="pl-smi">fst</span>, <span class="pl-smi">snd</span>) <span class="pl-k">=&gt;</span> [fst, snd];
<span class="pl-k">const</span> <span class="pl-c1">map</span> <span class="pl-k">=</span> (<span class="pl-smi">fn</span>, <span class="pl-smi">xs</span>) <span class="pl-k">=&gt;</span> <span class="pl-smi">xs</span>.<span class="pl-en">map</span>(fn);
<span class="pl-c">// simple helpers</span>

<span class="pl-k">const</span> <span class="pl-c1">zip</span> <span class="pl-k">=</span> (<span class="pl-smi">xs</span>, <span class="pl-smi">list</span>) <span class="pl-k">=&gt;</span> <span class="pl-en">map</span>((<span class="pl-smi">x</span>, <span class="pl-smi">idx</span>) <span class="pl-k">=&gt;</span> <span class="pl-en">pair</span>(x, list[idx]), xs);
<span class="pl-c">//define a zip based on the above `map` &amp; `pair` functions</span>

<span class="pl-en">zip</span>([<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>], [<span class="pl-s"><span class="pl-pds">'</span>a<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>b<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>c<span class="pl-pds">'</span></span>]); <span class="pl-c">//=&gt; [[1, 'a'], [2, 'b'], [3, 'c']]</span></pre></div>

<p>So far pretty straightforward, moving on:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">const</span> <span class="pl-c1">zipWith</span>  <span class="pl-k">=</span> (<span class="pl-smi">fn</span>, <span class="pl-smi">xs</span>, <span class="pl-smi">arr</span>) <span class="pl-k">=&gt;</span> <span class="pl-en">map</span>((<span class="pl-smi">x</span>, <span class="pl-smi">i</span>) <span class="pl-k">=&gt;</span> <span class="pl-smi">fn</span>.<span class="pl-c1">apply</span>(fn, <span class="pl-en">pair</span>(x, arr[i])), xs);

<span class="pl-en">zipWith</span>(f, [<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>], [<span class="pl-s"><span class="pl-pds">'</span>a<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>b<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>c<span class="pl-pds">'</span></span>]) <span class="pl-c">// [f(1, 'a'), f(2, 'b'), f(3, 'c')]</span>

<span class="pl-en">zipWith</span>((<span class="pl-smi">x</span>, <span class="pl-smi">y</span>) <span class="pl-k">=&gt;</span> [x, y], [<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>], [<span class="pl-s"><span class="pl-pds">'</span>a<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>b<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>c<span class="pl-pds">'</span></span>]) 
<span class="pl-c">// = zip([1, 2, 3], ['a', 'b', 'c']) =&gt; [[1, 'a'], [2, 'b'], [3, 'c']]</span></pre></div>

<h3>
<a id="what-do-we-have-so-far" class="anchor" href="#what-do-we-have-so-far" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>What do we have so far?</h3>

<ul>
<li>using <code>map</code> we build <code>zip</code> which takes two lists and pairs them up.</li>
<li>next we have <code>zipWith</code> that takes an additional argument: a function which gets called with both lists values.</li>
<li>finally we can also derive <code>zip</code> from <code>zipWith</code> shown above.</li>
</ul>

<p>Lets keep going!</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">const</span> <span class="pl-c1">inc</span> <span class="pl-k">=</span> <span class="pl-smi">num</span> <span class="pl-k">=&gt;</span> num <span class="pl-k">+</span> <span class="pl-c1">1</span>;
<span class="pl-k">const</span> <span class="pl-c1">addTen</span> <span class="pl-k">=</span> <span class="pl-smi">num</span> <span class="pl-k">=&gt;</span> num <span class="pl-k">+</span> <span class="pl-c1">10</span>;
<span class="pl-k">const</span> <span class="pl-c1">square</span> <span class="pl-k">=</span> <span class="pl-smi">num</span> <span class="pl-k">=&gt;</span> num <span class="pl-k">*</span> n;
<span class="pl-k">const</span> <span class="pl-c1">invoke</span> <span class="pl-k">=</span> (<span class="pl-smi">fn</span>, <span class="pl-k">...</span><span class="pl-v">args</span>) <span class="pl-k">=&gt;</span> <span class="pl-en">fn</span>(<span class="pl-k">...</span>args);

<span class="pl-en">zipWith</span>(invoke, [inc, addTen, square], [<span class="pl-c1">2</span>, <span class="pl-c1">4</span>, <span class="pl-c1">6</span>])
<span class="pl-c">// =&gt; [3, 14, 36]</span>

[<span class="pl-en">invoke</span>(inc, <span class="pl-c1">2</span>), <span class="pl-en">invoke</span>(addTen, <span class="pl-c1">4</span>), <span class="pl-en">invoke</span>(square, <span class="pl-c1">6</span>)] <span class="pl-c">//=&gt; [3, 14, 36]</span></pre></div>

<p>Here we are simply zipping a list of functions with a list of values.</p>

<p>The pair of functions and values get passed as arguments to <code>invoke</code>.</p>

<p>Lets further expand on the above function:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">const</span> <span class="pl-c1">max</span> <span class="pl-k">=</span> <span class="pl-c1">Math</span>.<span class="pl-smi">max</span>;
<span class="pl-k">const</span> <span class="pl-c1">zipThen</span> <span class="pl-k">=</span> (<span class="pl-smi">after</span>, <span class="pl-smi">xs</span>, <span class="pl-smi">list</span>) <span class="pl-k">=&gt;</span> <span class="pl-smi">after</span>.<span class="pl-c1">apply</span>(after, <span class="pl-en">zipWith</span>(invoke, xs, list));

<span class="pl-en">zipThen</span>(max, [inc, addTen, square], [<span class="pl-c1">2</span>, <span class="pl-c1">4</span>, <span class="pl-c1">6</span>]) <span class="pl-c">//=&gt; 36</span>

<span class="pl-en">max</span>(<span class="pl-k">...</span>[<span class="pl-en">invoke</span>(inc, <span class="pl-c1">2</span>), <span class="pl-en">invoke</span>(addTen, <span class="pl-c1">4</span>), <span class="pl-en">invoke</span>(square, <span class="pl-c1">6</span>)]) <span class="pl-c">//=&gt; 36</span></pre></div>

<p>We took our <code>zipWith(invoke)</code> and added a function to be called afterwards.</p>

<p>So 1st we <code>zip</code> list of functions with list of values and <code>then</code> we call <code>max</code> on the resulting list.</p>

<h3>
<a id="flashback-time" class="anchor" href="#flashback-time" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Flashback Time</h3>

<div class="highlight highlight-source-js"><pre><span class="pl-en">useWith</span>(max, [inc, addTen, square])(<span class="pl-c1">2</span>, <span class="pl-c1">4</span>, <span class="pl-c1">6</span>) <span class="pl-c">//=&gt; 36</span>

<span class="pl-en">zipThen</span>(max, [inc, addTen, square], [<span class="pl-c1">2</span>, <span class="pl-c1">4</span>, <span class="pl-c1">6</span>]) <span class="pl-c">//=&gt; 36</span></pre></div>

<p>The <a href="https://wiki.haskell.org/Type_signature">signatures</a> aren't identical but that shouldn't stop us!</p>

<p>Lets adjust the function definition:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">const</span> <span class="pl-c1">zipThen</span> <span class="pl-k">=</span> (<span class="pl-smi">after</span>, <span class="pl-smi">xs</span>) <span class="pl-k">=&gt;</span> (<span class="pl-k">...</span><span class="pl-v">list</span>) <span class="pl-k">=&gt;</span> <span class="pl-smi">after</span>.<span class="pl-c1">apply</span>(after, <span class="pl-en">zipWith</span>(invoke, xs, list));

<span class="pl-en">zipThen</span>(max, [inc, addTen, square])(<span class="pl-c1">2</span>, <span class="pl-c1">4</span>, <span class="pl-c1">6</span>) <span class="pl-c">//=&gt; 36</span>

<span class="pl-en">useWith</span>(max, [inc, addTen, square])(<span class="pl-c1">2</span>, <span class="pl-c1">4</span>, <span class="pl-c1">6</span>) <span class="pl-c">//=&gt; 36</span></pre></div>

<p>I don't know about you guys but I kinda like <code>zipThen</code> feels a bit more descriptive. ;)</p>

<h3>
<a id="footnotes" class="anchor" href="#footnotes" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Footnotes</h3>

<p>[^1]: a fipped function simply means we have reversed its arguments from <code>contains(needle, haystack)</code> to <code>contains(haystack, needle)</code></p>

<hr>

<h2>
<a id="short-cut-fusion" class="anchor" href="#short-cut-fusion" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Short cut fusion</h2>

<blockquote>
<p>Optimization techinque that allows for removal of intermediate data structures. <sup><a href="https://wiki.haskell.org/Short_cut_fusion">1</a></sup></p>
</blockquote>

<h5>
<a id="simple-example" class="anchor" href="#simple-example" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Simple Example:</h5>

<div class="highlight highlight-source-js"><pre><span class="pl-k">const</span> <span class="pl-c1">list</span> <span class="pl-k">=</span> [<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>,<span class="pl-c1">4</span>];


<span class="pl-c">//|- [12, 18, 24, 30] &lt;-- [4, 6, 8, 10] &lt;-- [2, 3, 4, 5] &lt;-- [1, 2, 3, 4]</span>
<span class="pl-k">const</span> <span class="pl-c1">f</span> <span class="pl-k">=</span> <span class="pl-en">compose</span>(<span class="pl-en">map</span>(triple), <span class="pl-en">map</span>(double), <span class="pl-en">map</span>(inc));

<span class="pl-en">f</span>(list); <span class="pl-c">// [12, 18, 24, 30]</span></pre></div>

<p>The above example is pretty straightforward we call <code>inc</code>, <code>double</code> and then <code>triple</code> on the 
given data <code>list</code>. For each of those function calls <code>map</code> creates a new list and passes it on
to the next <code>map(f)</code>. Seems a bit wasteful :(</p>

<div class="highlight highlight-source-js"><pre><span class="pl-c">//|- [12, 18, 24, 30] &lt;------------------ [1, 2, 3, 4]</span>
<span class="pl-k">const</span> ƒ <span class="pl-k">=</span> <span class="pl-en">map</span>(<span class="pl-en">compose</span>(triple, double, inc));

ƒ(list); <span class="pl-c">// [12, 18, 24, 30]</span></pre></div>

<p>Some what subtle but greatly beneficial improvement is to <code>compose</code> the functions provided to <code>map</code>
and then call <code>map</code> on the result of that accumulation. The result is the same, however instead of mapping 3x
over the same list it happens once. Therefore no unnecessary data structures created between the 1st function
call and the last.</p>

<h5>
<a id="more-involved-example" class="anchor" href="#more-involved-example" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>More Involved Example:</h5>

<div class="highlight highlight-source-js"><pre><span class="pl-k">const</span> <span class="pl-c1">list</span> <span class="pl-k">=</span> <span class="pl-en">range</span>(<span class="pl-c1">1</span>, <span class="pl-c1">10</span>);

<span class="pl-k">const</span> <span class="pl-c1">f</span> <span class="pl-k">=</span> <span class="pl-en">compose</span>(<span class="pl-en">map</span>(inc), <span class="pl-en">filter</span>(odd), <span class="pl-en">take</span>(<span class="pl-c1">3</span>)); <span class="pl-c">// [3, 5, 7]</span></pre></div>

<p>Looks very similar to 1st example, given a list we </p>

<ul>
<li>
<code>take</code> 3 values</li>
<li>
<code>filter</code> out the odd ones</li>
<li>
<code>map</code> to increment all of those values by 1</li>
</ul>

<p>This again suffers from creating gratuitous lists in between the 1st and last function call.</p>

<p>Ideally we would like to achieve a <code>composition</code> of those functions <code>take</code>, <code>filter</code> and <code>map</code> and
only "loop" through the data structure once.</p>

<p>Unfortunately due to the different function signatures, in their current form you cannot <code>compose</code> them together. IOW because <code>map</code> takes a function, <code>filter</code> takes a predicate function and <code>take</code> expects a number you cannot build a single function to accomdate all of those cases...</p>

<p>However if we re-define those functions in terms of something like <code>reduce</code> we may achieve the results
we want.</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">const</span> <span class="pl-c1">map</span>ƒ <span class="pl-k">=</span> (<span class="pl-smi">fn</span>, <span class="pl-smi">xs</span>) <span class="pl-k">=&gt;</span> <span class="pl-en">reduce</span>((<span class="pl-smi">acc</span>, <span class="pl-smi">input</span>) <span class="pl-k">=&gt;</span> <span class="pl-en">concat</span>(acc, <span class="pl-en">fn</span>(input)), [], xs);
<span class="pl-k">const</span> <span class="pl-c1">filter</span>ƒ <span class="pl-k">=</span> (<span class="pl-smi">pred</span>, <span class="pl-smi">xs</span>) <span class="pl-k">=&gt;</span> <span class="pl-en">reduce</span>((<span class="pl-smi">acc</span>, <span class="pl-smi">input</span>) <span class="pl-k">=&gt;</span> <span class="pl-en">pred</span>(input) <span class="pl-k">?</span> <span class="pl-en">concat</span>(acc, <span class="pl-en">pred</span>(input)) <span class="pl-k">:</span> acc, [], xs);
<span class="pl-k">const</span> <span class="pl-c1">take</span>ƒ <span class="pl-k">=</span> (<span class="pl-smi">n</span>, <span class="pl-smi">xs</span>) <span class="pl-k">=&gt;</span> <span class="pl-en">reduce</span>((<span class="pl-smi">acc</span>, <span class="pl-smi">input</span>) <span class="pl-k">=&gt;</span> <span class="pl-smi">acc</span>.<span class="pl-c1">length</span> <span class="pl-k">!==</span> n <span class="pl-k">?</span> <span class="pl-en">concat</span>(acc, input) <span class="pl-k">:</span> acc, [], xs);</pre></div>

<p>This 1st pass shows that we are internally dependent on <code>reduce</code> and <code>concat</code> which we use to accumulate the values. This current situation does not allow us to be flexible in our usage of these new functions. IOW we cannot start with a list of values and return a single value ie: <code>[1,2,3,4] =&gt; 10</code> </p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">const</span> <span class="pl-c1">map</span>ƒ <span class="pl-k">=</span> (<span class="pl-smi">fn</span>, <span class="pl-smi">combineFn</span>) <span class="pl-k">=&gt;</span> (<span class="pl-smi">acc</span>, <span class="pl-smi">input</span>) <span class="pl-k">=&gt;</span> <span class="pl-en">combineFn</span>(acc, <span class="pl-en">fn</span>(input));
<span class="pl-k">const</span> <span class="pl-c1">filter</span>ƒ <span class="pl-k">=</span> (<span class="pl-smi">pred</span>, <span class="pl-smi">combineFn</span>) <span class="pl-k">=&gt;</span> (<span class="pl-smi">acc</span>, <span class="pl-smi">input</span>) <span class="pl-k">=&gt;</span> <span class="pl-en">pred</span>(input) <span class="pl-k">?</span> <span class="pl-en">combineFn</span>(acc, input) <span class="pl-k">:</span> acc;
<span class="pl-k">const</span> <span class="pl-c1">take</span>ƒ <span class="pl-k">=</span> (<span class="pl-smi">n</span>, <span class="pl-smi">combineFn</span>) <span class="pl-k">=&gt;</span> (<span class="pl-smi">acc</span>, <span class="pl-smi">input</span>) <span class="pl-k">=&gt;</span> <span class="pl-smi">acc</span>.<span class="pl-c1">length</span> <span class="pl-k">!==</span> n <span class="pl-k">?</span> <span class="pl-en">combineFn</span>(acc, input) <span class="pl-k">:</span> acc;
</pre></div>

<p>In this 2nd attempt we have removed the dependency on a internal <code>reduce</code> function as well as a way to accumulate the values. It is now an argument called <code>combineFn</code>. So now we have 3 new functions that
have a way to accumulate values and a reducing function with the signature <code>(acc, input)</code> which is the same as the 1st argument to reduce.</p>

<div class="highlight highlight-source-js"><pre><span class="pl-en">reduce</span>(mapƒ(<span class="pl-en">add</span>(<span class="pl-c1">10</span>), concat), [], <span class="pl-en">range</span>(<span class="pl-c1">1</span>, <span class="pl-c1">5</span>)); <span class="pl-c">// [11, 12, 13, 14]</span></pre></div>

<p>Above we have a typical usage of the newly created <code>mapβ</code> using <code>concat</code> as the <code>combineFn</code></p>

<div class="highlight highlight-source-js"><pre><span class="pl-en">reduce</span>(mapƒ(inc, add), <span class="pl-c1">0</span>, <span class="pl-en">range</span>(<span class="pl-c1">1</span>, <span class="pl-c1">5</span>)); <span class="pl-c">// 14</span></pre></div>

<p>In this example we use <code>add</code> as the accumulator (combineFn).</p>

<div class="highlight highlight-source-js"><pre><span class="pl-en">reduce</span>(mapƒ(inc, filterƒ(odd, takeƒ(<span class="pl-c1">3</span>, concat))), [], <span class="pl-en">range</span>(<span class="pl-c1">1</span>, <span class="pl-c1">10</span>)); <span class="pl-c">// [3, 5, 7]</span></pre></div>

<p>Finally we can create a function "composition" with all of the new functions as well as a way to accumulate values. We get the same results as the example at the beginning of this section... but with a single "loop" and no intermediate data structures</p>

<p><em>Bonus:</em></p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">const</span> <span class="pl-c1">map</span>ƒ <span class="pl-k">=</span> <span class="pl-en">curryN</span>(<span class="pl-c1">2</span>, (<span class="pl-smi">fn</span>, <span class="pl-smi">combineFn</span>) <span class="pl-k">=&gt;</span> (<span class="pl-smi">acc</span>, <span class="pl-smi">input</span>) <span class="pl-k">=&gt;</span> <span class="pl-en">combineFn</span>(acc, <span class="pl-en">fn</span>(input)));
<span class="pl-k">const</span> <span class="pl-c1">filter</span>ƒ <span class="pl-k">=</span> <span class="pl-en">curryN</span>(<span class="pl-c1">2</span>, (<span class="pl-smi">pred</span>, <span class="pl-smi">combineFn</span>) <span class="pl-k">=&gt;</span> (<span class="pl-smi">acc</span>, <span class="pl-smi">input</span>) <span class="pl-k">=&gt;</span> <span class="pl-en">pred</span>(input) <span class="pl-k">?</span> <span class="pl-en">combineFn</span>(acc, input) <span class="pl-k">:</span> acc);
<span class="pl-k">const</span> <span class="pl-c1">take</span>ƒ <span class="pl-k">=</span> <span class="pl-en">curryN</span>(<span class="pl-c1">2</span>, (<span class="pl-smi">n</span>, <span class="pl-smi">combineFn</span>) <span class="pl-k">=&gt;</span> (<span class="pl-smi">acc</span>, <span class="pl-smi">input</span>) <span class="pl-k">=&gt;</span> <span class="pl-smi">acc</span>.<span class="pl-c1">length</span> <span class="pl-k">!==</span> n <span class="pl-k">?</span> <span class="pl-en">combineFn</span>(acc, input) <span class="pl-k">:</span> acc);

<span class="pl-k">const</span> ƒ <span class="pl-k">=</span> <span class="pl-en">compose</span>(mapƒ(inc), filterƒ(<span class="pl-smi">x</span> <span class="pl-k">=&gt;</span> x <span class="pl-k">%</span> <span class="pl-c1">2</span> <span class="pl-k">!==</span> <span class="pl-c1">0</span>), takeƒ(<span class="pl-c1">3</span>));

<span class="pl-en">reduce</span>(ƒ(concat), [], <span class="pl-en">range</span>(<span class="pl-c1">1</span>, <span class="pl-c1">10</span>)) <span class="pl-c">// [3, 5, 7]</span></pre></div>

<p>As a bonus using <code>curryN</code> and <code>compose</code> from a library like <a href="http://ramdajs.com">ramda</a>. We can create nice reusable compositions for our <code>reduce</code> function. <strong>NB</strong> typical composition is right-left but in our case the functions get applied left-right (map gets called 1st).</p>

<h4>
<a id="references" class="anchor" href="#references" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>References</h4>

<ul>
<li><a href="https://wiki.haskell.org/Short_cut_fusion">https://wiki.haskell.org/Short_cut_fusion</a></li>
<li><a href="http://www.slideshare.net/drboolean/millionways">http://www.slideshare.net/drboolean/millionways</a></li>
</ul>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/davidchase/fp-notes">FP Notes</a> is maintained by <a href="https://github.com/davidchase">davidchase</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
